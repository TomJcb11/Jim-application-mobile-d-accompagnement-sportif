<<<<<<< HEAD
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.valueFromAST = valueFromAST;

var _objectValues3 = _interopRequireDefault(require("../polyfills/objectValues"));

var _keyMap = _interopRequireDefault(require("../jsutils/keyMap"));

var _inspect = _interopRequireDefault(require("../jsutils/inspect"));

var _invariant = _interopRequireDefault(require("../jsutils/invariant"));

var _kinds = require("../language/kinds");

var _definition = require("../type/definition");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
=======
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true,
});
exports.valueFromAST = valueFromAST;

var _inspect = require('../jsutils/inspect.js');

var _invariant = require('../jsutils/invariant.js');

var _keyMap = require('../jsutils/keyMap.js');

var _kinds = require('../language/kinds.js');

var _definition = require('../type/definition.js');
>>>>>>> origin/main

/**
 * Produces a JavaScript value given a GraphQL Value AST.
 *
 * A GraphQL type must be provided, which will be used to interpret different
 * GraphQL Value literals.
 *
 * Returns `undefined` when the value could not be validly coerced according to
 * the provided type.
 *
 * | GraphQL Value        | JSON Value    |
 * | -------------------- | ------------- |
 * | Input Object         | Object        |
 * | List                 | Array         |
 * | Boolean              | Boolean       |
 * | String               | String        |
 * | Int / Float          | Number        |
<<<<<<< HEAD
 * | Enum Value           | Mixed         |
=======
 * | Enum Value           | Unknown       |
>>>>>>> origin/main
 * | NullValue            | null          |
 *
 */
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    // When there is no node, then there is also no value.
    // Importantly, this is different from returning the value null.
    return;
  }

  if (valueNode.kind === _kinds.Kind.VARIABLE) {
<<<<<<< HEAD
    var variableName = valueNode.name.value;
=======
    const variableName = valueNode.name.value;
>>>>>>> origin/main

    if (variables == null || variables[variableName] === undefined) {
      // No valid return value.
      return;
    }

<<<<<<< HEAD
    var variableValue = variables[variableName];
=======
    const variableValue = variables[variableName];
>>>>>>> origin/main

    if (variableValue === null && (0, _definition.isNonNullType)(type)) {
      return; // Invalid: intentionally return no value.
    } // Note: This does no further checking that this variable is correct.
    // This assumes that this query has been validated and the variable
    // usage here is of the correct type.

<<<<<<< HEAD

=======
>>>>>>> origin/main
    return variableValue;
  }

  if ((0, _definition.isNonNullType)(type)) {
    if (valueNode.kind === _kinds.Kind.NULL) {
      return; // Invalid: intentionally return no value.
    }

    return valueFromAST(valueNode, type.ofType, variables);
  }

  if (valueNode.kind === _kinds.Kind.NULL) {
    // This is explicitly returning the value null.
    return null;
  }

  if ((0, _definition.isListType)(type)) {
<<<<<<< HEAD
    var itemType = type.ofType;

    if (valueNode.kind === _kinds.Kind.LIST) {
      var coercedValues = [];

      for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {
        var itemNode = _valueNode$values2[_i2];

=======
    const itemType = type.ofType;

    if (valueNode.kind === _kinds.Kind.LIST) {
      const coercedValues = [];

      for (const itemNode of valueNode.values) {
>>>>>>> origin/main
        if (isMissingVariable(itemNode, variables)) {
          // If an array contains a missing variable, it is either coerced to
          // null or if the item type is non-null, it considered invalid.
          if ((0, _definition.isNonNullType)(itemType)) {
            return; // Invalid: intentionally return no value.
          }

          coercedValues.push(null);
        } else {
<<<<<<< HEAD
          var itemValue = valueFromAST(itemNode, itemType, variables);
=======
          const itemValue = valueFromAST(itemNode, itemType, variables);
>>>>>>> origin/main

          if (itemValue === undefined) {
            return; // Invalid: intentionally return no value.
          }

          coercedValues.push(itemValue);
        }
      }

      return coercedValues;
    }

<<<<<<< HEAD
    var coercedValue = valueFromAST(valueNode, itemType, variables);
=======
    const coercedValue = valueFromAST(valueNode, itemType, variables);
>>>>>>> origin/main

    if (coercedValue === undefined) {
      return; // Invalid: intentionally return no value.
    }

    return [coercedValue];
  }

  if ((0, _definition.isInputObjectType)(type)) {
    if (valueNode.kind !== _kinds.Kind.OBJECT) {
      return; // Invalid: intentionally return no value.
    }

<<<<<<< HEAD
    var coercedObj = Object.create(null);
    var fieldNodes = (0, _keyMap.default)(valueNode.fields, function (field) {
      return field.name.value;
    });

    for (var _i4 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i4 < _objectValues2.length; _i4++) {
      var field = _objectValues2[_i4];
      var fieldNode = fieldNodes[field.name];
=======
    const coercedObj = Object.create(null);
    const fieldNodes = (0, _keyMap.keyMap)(
      valueNode.fields,
      (field) => field.name.value,
    );

    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
>>>>>>> origin/main

      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== undefined) {
          coercedObj[field.name] = field.defaultValue;
        } else if ((0, _definition.isNonNullType)(field.type)) {
          return; // Invalid: intentionally return no value.
        }

        continue;
      }

<<<<<<< HEAD
      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);
=======
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
>>>>>>> origin/main

      if (fieldValue === undefined) {
        return; // Invalid: intentionally return no value.
      }

      coercedObj[field.name] = fieldValue;
    }

    return coercedObj;
<<<<<<< HEAD
  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')

=======
  }
>>>>>>> origin/main

  if ((0, _definition.isLeafType)(type)) {
    // Scalars and Enums fulfill parsing a literal value via parseLiteral().
    // Invalid values represent a failure to parse correctly, in which case
    // no value is returned.
<<<<<<< HEAD
    var result;
=======
    let result;
>>>>>>> origin/main

    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return; // Invalid: intentionally return no value.
    }

    if (result === undefined) {
      return; // Invalid: intentionally return no value.
    }

    return result;
<<<<<<< HEAD
  } // istanbul ignore next (Not reachable. All possible input types have been considered)


  false || (0, _invariant.default)(0, 'Unexpected input type: ' + (0, _inspect.default)(type));
} // Returns true if the provided valueNode is a variable which is not defined
// in the set of variables.


function isMissingVariable(valueNode, variables) {
  return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
=======
  }
  /* c8 ignore next 3 */
  // Not reachable, all possible input types have been considered.

  false ||
    (0, _invariant.invariant)(
      false,
      'Unexpected input type: ' + (0, _inspect.inspect)(type),
    );
} // Returns true if the provided valueNode is a variable which is not defined
// in the set of variables.

function isMissingVariable(valueNode, variables) {
  return (
    valueNode.kind === _kinds.Kind.VARIABLE &&
    (variables == null || variables[valueNode.name.value] === undefined)
  );
>>>>>>> origin/main
}
